# 数据库基础知识总结

## 数据库范式了解吗?

![image-20220227210545915](http://img.whaifree.top/image-resp/image-20220227210545915.png)

![image-20220227210608137](http://img.whaifree.top/image-resp/image-20220227210608137.png)

### **1NF**（不可再分）

每个关系r的属性值都是不可分的原子值

数据库表的每一列都是**不可分割的原子数据项**，而***\*不能是集合，数组，记录等非原子数据项\****

> - `高三年1班` 应改为2个字段，一个年级、一个班级，才满足第一范式
>
> - 一个属性包含了多个电话号码的列表（"123-456-7890, 987-654-3210"）
>
>   ```java
>   | Student_ID | Student_Name | Courses                        |
>   |------------|--------------|--------------------------------|
>   | 1          | Alice        | Math, Physics                  |
>   ```

### **2NF**（非主属性完全依赖于候选键）

关系模式R是1NF，且==每个非主属性**完全函数依赖**于**候选键**(没有冗余属性)==

> ```
> | *订单id  | *产品id     | 产品名称       | *顾客id      |  顾客名称       |
> |----------|------------|--------------|-------------|---------------|
> | 1        | 101        | Laptop       | 1001        | Alice         |
> | 2        | 102        | Smartphone   | 1002        | Bob           |
> | 3        | 101        | Laptop       | 1003        | Charlie       |
> ```
>
> ```
> | *产品id     | 产品名称      |
> |------------|--------------|
> | 101        | Laptop       |
> | 102        | Smartphone   |
> 
> | *顾客id     | 顾客名称        |
> |-------------|---------------|
> | 1001        | Alice         |
> | 1002        | Bob           |
> | 1003        | Charlie       |
> 
> | *订单id   | 产品id     | 顾客id       | 订单数量        |
> |----------|------------|-------------|----------------|
> | 1        | 101        | 1001        | 2              |
> | 2        | 102        | 1002        | 1              |
> | 3        | 101        | 1003        | 3              |
> ```
>
> Name与id挂钩，在订单表里不需要有，**不要冗余属性**

### **3NF**（非主属性没有传递依赖）

表中的非主键只依赖于主键，而不依赖于其他非主键

 如果关系模式R是1NF，且==每个非主属性都不传递依赖于R的候选键==，那么称R是第三范式（3NF）的模式。

- **R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖**

> ```
> | *课程id    | 课程名称     | *教师id       | 教师名称         | 部门             |
> |-----------|-------------|--------------|-----------------|------------------|
> | 101       | Math        | 501          | Dr. Smith       | Mathematics      |
> | 102       | Physics     | 502          | Dr. Johnson     | Physics          |
> | 103       | Chemistry   | 503          | Dr. Davis       | Chemistry        |
> ```
>
> - 教师名称-->教师id--->课程id
>
> ```
> | *教师id      | 教师名称          | 部门              |
> |--------------|-----------------|------------------|
> | 501          | Dr. Smith       | Mathematics      |
> | 502          | Dr. Johnson     | Physics          |
> | 503          | Dr. Davis       | Chemistry        |
> 
> | *课程id    | 课程名称     | 教师id        |
> |-----------|-------------|--------------|
> | 101       | Math        | 501          |
> | 102       | Physics     | 502          |
> | 103       | Chemistry   | 503          |
> ```

### **BC范式**（主属性没有传递依赖）

每个属性都不传递依赖于R的候选键，那么称R是BCNF的模式

- 彻底消除了插入、删除异常。

> ```
> | *员工id      | 员工名称       | *部门       | 部门位置             |
> |-------------|---------------|------------|---------------------|
> | 1001        | Alice         | HR         | New York            |
> | 1002        | Bob           | IT         | San Francisco       |
> | 1003        | Charlie       | HR         | New York            |
> ```
>
> ```
> | *部门       |  部门位置            |
> |------------|---------------------|
> | HR         | New York            |
> | IT         | San Francisco       |
> 
> | *员工id     | 员工名称        | 部门        |
> |-------------|---------------|------------|
> | 1001        | Alice         | HR         |
> | 1002        | Bob           | IT         |
> | 1003        | Charlie       | HR         |
> ```



## 什么是级联更新？为什么不推荐使用外键与级联？

- 同时触发成绩表中的 外键student_id 更新，即为级联更新。

外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

**为什么不使用？**

1. 复杂性，每次update、delete都需要考虑外键
2. 额外工作，
3. 对分库分表不友好，分库外键不生效

## 索引

### 索引是什么？

> 索引可以大大提高MySQL的检索速度
>
> **索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录**
>
> 优点：提高查询速度
> 缺点：降低更新速度，更新时还要进一步保存索引文件
>
> ```sql
> CREATE INDEX index_name
> ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
> ```

