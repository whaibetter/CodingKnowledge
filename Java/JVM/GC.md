[TOC]

## GC

### Java 垃圾回收机制?GC的地方？有什么方法？

- GC 主要关注于 方法区 和堆中的垃圾收集

1. 哪些垃圾要回收？**标记**
   - <mark>引用计数算法</mark>：引用计数器
   - <mark>可达性分析算法</mark>
2. 怎么回收清除？**清除**
   - ==标记-清除==
   - ==复制算法==
   - ==标记-清除-压缩（标记-压缩算法）==

### 有什么垃圾回收算法？优缺点？

#### 方式一：引用计数算法

==每个对象保存一个整型的**引用计数器（记录对象被引用的情况）**==

优点：实现简单、效率高、无延迟，随时可以进行GC

缺点：需要存储空间、**赋值操作**需要时间开销、==无法解决**循环引用**==

p不使用这三个对象，会让这3个对象一直保留，**内存泄露（无法被回收）**

![image-20200712102205795](http://42.192.130.83:9000/picgo/imgs/1367a58058e6653d53afdea83b937af3.png)

#### 方式二：可达性分析算法

- **根对象集合（GCRoots）**为起始点，按照从上至下的方式<mark>搜索被根对象集合所连接的目标对象是否可达</mark>

- 没有任何引用链相连，则是不可达的

![image-20210511195540451](http://42.192.130.83:9000/picgo/imgs/071039dcf30672f55dfe8e5dab5e8081.png)

### 虚拟机中的对象可能的三种状态？

1. <mark>可触及的（*活的*）</mark>：从根节点开始，**可以到达这个对象**。
2. <mark>可复活的（*还未finalize*）</mark>：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。*（刀下留人）*
3. <mark>不可触及的（*已经finalize*）</mark>：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态（**这时才能回收**）。不可触及的对象不可能被复活，因为<mark>finalize()只会被调用一次</mark>。

### 清除的算法有哪些？优缺点？适合什么时候使用？

#### 标记清除

1. 根据可达性，**标记有被引用**的对象。
2. Collector 对堆遍历，如果**没有被标记**的清除

缺点：空间不连续，STW，效率

![image-20200712150935078](http://42.192.130.83:9000/picgo/imgs/8ea506a5c45c10410418ff0403e2b3a8.png)

#### 复制算法

- 如栈新生代 S0 S1 区，**将存活对象复制到另一块**

**适合新生代，经常被GC，量不大**

缺点：

1. 两倍空间
2. 改变地址（对于G1意味着**变量指针**也要不断移动｛句柄池｝）
3. 如果存活很多对象，效率不高

#### 标记-压缩-清除算法

1. 根据可达性，**标记有被引用**的对象。
2. 对**活的对象**压缩到一端，顺序排放。
3. 清理边界空间

缺点：碎片整理时间、STW、引用地址变换

![image-20200712153236508](http://42.192.130.83:9000/picgo/imgs/aac06de20fada1a602f1955010bd969d.png)

###  分代收集算法是什么？有什么样的对象适合这样存？

<mark>不同生命周期的对象可以采取不同的收集方式</mark>，以便提高回收效率。

- 生命周期长：<mark>Http 请求中的 Session 对象、线程、Socket 连接</mark>
- 生命周期短：<mark>String 对象</mark>

年轻代（Young Gen）：S0 S1 适合**复制算法**

老年代（Tenured Gen）：由**标记-清除**或者是**标记-清除与标记-整理**的混合实现

### 增量收集算法是什么？

基本思想：==交替执行GC和Application线程==，**逐步收集（慢慢增加的收集）**

==垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成==

优点：不至于一直STW

缺点：需要进行线程切换



### 指针碰撞（Bump the Pointer）是什么

- 用一个**指针**标记内存应该存放的地方，**一边为占用的，一边为空闲的**

如果内存空间以**规整和有序的方式分布**，即已用和未用的内存都各自一边，彼此之间维系着一个**记录下一次分配起始点的标记指针**，当为**新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上**，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。