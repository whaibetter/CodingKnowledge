[toc]

## 垃圾回收器

### GC有哪些常用评估指标？

- 吞吐量：用户运行时间/总运行时间
- 暂停时间：GC时被STW时间，单次STW时间

如果用户运行时间增加，**线程切换时间要减少**，那么GC时STW时间会增加。

如果单次STW时间减少，线程切换频繁，必然会降低用户运行时间的占比

![image-20200713084726176](http://42.192.130.83:9000/picgo/imgs/a05d48c1926a03c3acdebf74d10bf522.png)

![image-20200713085306400](http://42.192.130.83:9000/picgo/imgs/de90092e21cbff31926f7cc7dceebf25.png)

### 了解哪些垃圾回收器？

- 串行回收器：Serial、Serial Old 只有一个GC线程，用户线程要停止
  - 没有线程切换开销；无法使用多核心，适合性能差的。
- 并行回收器：ParNew、Parallel Scavenge、Parallel old 多个GC线程一起
  - 利用多核处理器，并发访问会有问题。
- **并发回收器：CMS、G1 ** 用户线程、垃圾回收线程交替并发
  - 响应快，**最小化停顿时间**

![image-20200713093551365](http://42.192.130.83:9000/picgo/imgs/90c3bcdc22cd0b49e10d702c608c4fc6.png)

![image-20200713093757644](http://42.192.130.83:9000/picgo/imgs/fd16701d3e150d5e58d52b7306473a42.png)

- 新生代收集器：Serial、ParNew、Parallel Scavenge；
- 老年代收集器：Serial Old、Parallel Old、CMS；
- 整堆收集器：G1；

截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。

- 新生代一般都是复制算法
- 老年代--标记压缩、标记清除

| 垃圾收集器   | 分类           | 作用位置             | 使用算法                                                     | 特点             | 适用场景                                     |
| :----------- | :------------- | :------------------- | :----------------------------------------------------------- | :--------------- | :------------------------------------------- |
| Serial       | **串行运行**   | 作用于**新生代**     | **复制算法**                                                 | 响应速度优先     | 适用于**单 CPU** 环境下的 client 模式        |
| ParNew       | 并行运行       | 作用于新生代         | 复制算法                                                     | 响应速度优先     | **多 CPU** 环境 Server 模式下与 CMS 配合使用 |
| Parallel     | 并行运行       | 作用于新生代         | 复制算法                                                     | 吞吐量优先       | 适用于**后台运算**而不需要太多交互的场景     |
| Serial Old   | 串行运行       | 作用于老年代         | 标记-压缩算法                                                | 响应速度优先     | 适用于**单 CPU** 环境下的 Client 模式        |
| Parallel Old | 并行运行       | 作用于老年代         | 标记-压缩算法                                                | 吞吐量优先       | 适用于**后台运算**而不需要太多交互的场景     |
| CMS          | 并发运行       | 作用于老年代         | 标记-清除算法                                                | **响应速度优先** | 适用于互联网或 B／S 业务                     |
| G1           | 并发、并行运行 | 作用于新生代、老年代 | **标记-压缩算法、复制算法**<br />回收是复制算法、整理是压缩算法。 | 响应速度优先     | 面向服务端应用                               |

GC 发展阶段：Serial => Parallel（并行）=> CMS（并发）=> G1（限定时延内提升吞吐量） => ZGC

### Serial 回收器的工作流程？优缺点？

> Serial GC（Serial、Serial old）
>
> - 新生代：**复制算法**、串行回收、新生代收集。
> - 老年代：Serial Old 收集器（CMS的备用方案）、**标记压缩算法**（指针碰撞）。
>
>
> 优点：简单，不用线程交互；适合单核CPU
>
> 缺点：STW
>
> ![image-20200713100703799](http://42.192.130.83:9000/picgo/imgs/d66b612e68381df2101c3e829a18b4f0.png)

### ParNew 回收器的工作流程？优缺点？

> ParNew 回收器: Parallel New（新生代使用Parallel）
>
> - Serial 收集器的**多线程版本**。在new新生代并行回收 。
> - 新生代：**复制算法**、**并行回收**、新生代收集。
> - 老年代：Serial Old 收集器（CMS的备用方案）、**标记压缩算法**（指针碰撞）。
>
> 优点：简单，多核下更高效。
>
> 缺点：STW
>
> ![image-20200713102030127](http://42.192.130.83:9000/picgo/imgs/187fdcd46a1cb35be6d88a01a433c0f3.png)
>

### Parallel 回收器的工作流程？优缺点？

> - **吞吐量优先**
> - 目标则是达到一个<mark>可控制的吞吐量</mark>（Throughput）
> - JDK1.6后提供了 Parallel Old 收集器
> - 复制+标记压缩
> - JDK8默认
>
> 优点：**吞吐量**
>
> 缺点：STW
>
> ![image-20200713110359441](http://42.192.130.83:9000/picgo/imgs/8a4b655ee277aaf0f9a46754248ce05a.png)

### CMS 回收的工作流程？优缺点？

> - **低延迟**，适合强交互（BS），缩短停顿时间。
> - HotSpot 虚拟机中第一款真正意义上的**并发收集器**
>   - 过程
>     1. 初始标记：GCRoots 能**直接关联**到的对象，STW
>     2. 并发标记：并发遍历全部对象（耗时，但并发）
>     3. 重新标记：标记**并发过程**中的**变动**，STW
>     4. 并发清除：清除（耗时，但并发）
> - 优点：并发操作（只有1 3 需要STW）、低延迟、强交互（并发标记耗时，但低停顿）。
> - 缺点：**内存碎片**（**空闲列表**，放不下大对象会Full GC）；CPU敏感，吞吐量降低；**浮动垃圾**（并发标记的新垃圾无法收集）
>
> ![image-20200713205154007](http://42.192.130.83:9000/picgo/imgs/f84a132db8c56a488e14f51e2c4d7fa7.png)
>
> 需要结合其他GC使用
>
> ![image-20200713094745366](http://42.192.130.83:9000/picgo/imgs/b92c2212bea2907cb75ff9ef26f346fe.png)

### 内存碎片是什么？怎么解决？

CMS 收集器的垃圾收集算法采用的是**标记清除算法**，不进行压缩，会产生很多碎片。

不使用Sweep Compact是因为**Compact需要STW**。

- 使用**空闲列表**
- 如果是压缩算法，可以用指针碰撞。

### 如何选择**Serial GC、Parallel GC、Concurrent Mark Sweep GC** 。

- 单CPU： **Serial GC**+Serial Old
- 吞吐量优先：**Parallel GC**+Parallel Old
- 低延迟：**CMS GC**+ParNew

### G1 回收器的工作流程？优缺点？

> - 将内存**划分为多个Region**，不进行全区域扫描，使用优先列表，回收时只回收收益最大的（年龄、存活时间）。
>
> - 优点：
>
>   1. 并行+并发
>   2. 分代收集（e,s,o,h）、MixGC、Region之间复制算法
>
> - 缺点：
>
>   1. 内存占用高，所以适合大内存
>
> - 过程：
>
>   1. **初始标记**：GCRoot直接关联，STW
>   2. **并发标记**：找出全部存活对象
>   3. 最终标记：并发阶段结束后的引用变动，STW
>   4. 筛选回收：根据回收价值排序，复制到其他Region
>
>   - Mix GC：部分Old+Young GC
>
> ![G1 收集器](http://42.192.130.83:9000/picgo/imgs/g1-garbage-collector.png)
>
> ![image-20200713223244886](http://42.192.130.83:9000/picgo/imgs/74c611464ae6cdae3cbfffaef213cfd5.png)

### GC跨区域引用对象怎么解决?

- **不管是G1还是其他分代收集器，JVM都是使用==记忆集(Remembered Set)== 来避免全局扫描**
  - **每个Region都有一个对应的记忆集。**
  - Reference类型数据**写操作**时，都会产生一个 **写屏障（Write Barrier）**暂时去终止操作
  - 检查是否存在**跨代引用**
  - GCollection 时，在GC Roots范围加上RSet

G1的RSet可以理解为一个哈希表，Key就是别的Region的起始地址，Value就是卡表的索引号集合。

![**G1的记忆集可以理解为一个哈希表，Key就是别的Region的起始地址，Value就是卡表的索引号集合。**](https://img-blog.csdnimg.cn/img_convert/c97de4bdada1da5a9fdd344692ed0957.png)

### G1和CMS的区别？

- G1整体上似乎是标记-整理、但Region内其实是复制算法（**整理**）；CMS是标记-清除算法（**无整理**）。
- G1使用了全新的内存划分方法。
- CMS只回收老年代，G1通用
- CMS适合追求低延迟，G1希望在保证吞吐量的前提下降低延迟。

### Remember Set的作用？什么是Card Table？

跟踪其它**Region**指向该**Region**中**对象的引用**

1. 跨代引用记录。
2. 增量标记，并发标记时的增量记录。
3. 避免GC全局扫描。

Card Table（卡表）就是 Remembered Set 卡精度的具体实现

### 有关GC的虚拟机参数？

1. **堆、方法区大小参数**：
   - -Xms：初始堆大小。
   - -Xmx：最大堆大小。
   - -XX:NewSize、-XX:MaxNewSize：设置年轻代的初始大小和最大大小。
   - -XX:OldSize、-XX:MaxOldSize：设置老年代的初始大小和最大大小。
   - -XX:InitialHeapSize：设置Java虚拟机的初始堆大小。
   - -XX:MaxHeapSize：设置Java虚拟机的最大堆大小。
   - -XX:MetaspaceSize、-XX:MaxMetaspaceSize：设置元空间（Metaspace）的初始大小和最大大小。

2. **分代收集参数**：
   - **-XX:NewRatio：设置年轻代和老年代大小的比例。**
   - -XX:SurvivorRatio：设置两个Survivor区的大小比例。
   - -XX:MaxTenuringThreshold：设置对象晋升到老年代所需的年龄阈值。

3. **垃圾回收器选择参数**：
   - -XX:+UseParallelGC：启用并行垃圾回收器。
   - -XX:+UseConcMarkSweepGC：启用并发标记清除垃圾回收器。
   - -XX:+UseG1GC：启用G1垃圾回收器。

4. **线程数目参数**：
   - **-XX:ParallelGCThreads：设置并行垃圾回收器的线程数目。**
   - **-XX:ConcGCThreads：设置并发垃圾回收器的线程数目。**

5. **日志输出参数**：
   - -XX:+PrintGCDetails：打印垃圾回收器的详细信息。
   - -XX:+PrintGCDateStamps：打印垃圾回收器操作的日期时间戳。

这些参数根据它们的作用和影响可以帮助调整Java应用程序的性能和稳定性，具体的参数配置应该根据实际情况和需求进行调整。


