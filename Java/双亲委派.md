## 双亲委派机制扩展，tomcat打破双亲委派机制

在初学时部署项目，我们是**把war包放到tomcat的webapp下**，这意味着**一个tomcat可以运行多个Web应用程序**

假设两个war都有User会冲突。

Tomcat给每个 Web 应用创建一个**类加载器实例（WebAppClassLoader），该加载器重写了loadClass方法**，**优先加载当前应用目录下的类**，如果当前找不到了，才一层一层往上找

```java
public class WebappClassLoader extends WebappClassLoaderBase

org.apache.catalina.loader.WebappClassLoaderBase#loadClass(java.lang.String, boolean)
```

![img](http://42.192.130.83:9000/picgo/imgs/v2-13bc25c596dd5b63c2821d3c7bc18816_720w.webp)

## 如何自定义类加载器进行类加载？

- 继承`java.lang.ClassLoader`
- 在`findClass`方法中实现从特定的位置（例如文件系统、网络等）加载类的字节码，并通过调用`defineClass`方法将字节码转换为`Class`对象。
- 可以通过重写`getParent`方法指定父类加载器

```java
public class MyClassLoader extends ClassLoader {
    private String classPath;

    public MyClassLoader(String classPath) {
        this.classPath = classPath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] data = loadClassData(name);
        // 将字节码转换为`Class`对象
        return defineClass(name, data, 0, data.length);
    }

    private byte[] loadClassData(String name) {
        // 从指定路径加载类文件，并将其转换为字节数组
        // ...
    }
    
    public final ClassLoader getParent() {
        // d
    }
}
```

1. findClass

findClass方法是ClassLoader的保护方法，它负责查找类文件，并将其转换为字节数组，然后通过defineClass方法将其加载到内存中。如果要自定义类加载器，必须覆盖findClass方法，并实现自己的类加载逻辑。

1. loadClass

loadClass方法是ClassLoader的公共方法，它负责加载类文件，并将其转换为字节数组，然后通过defineClass方法将其加载到内存中。loadClass方法首先会调用父类加载器的loadClass方法，如果父类加载器无法加载该类文件，则会调用自己的findClass方法来加载类文件。