# 分布式锁

### 为什么要使用分布式？

- 单机下可以使用悲观锁**实现共享资源的互斥访问**

-  `ReetrantLock` 类、`synchronized` 

  ![本地锁](http://42.192.130.83:9000/picgo/imgs/jvm-local-lock.png)

- **多个 JVM 进程**共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。

### 分布式锁应该具备哪些条件？

- 互斥：只能被一个线程拥有
- 高可用：锁失效能够切换另一个锁
- 可重入：可多次获取锁

其次：高性能，非阻塞（获取不到、不能无限等待）

### 分布式锁的常见实现方式有哪些？

- 关系数据库 唯一索引，排他锁，性能差
- Zookeeper
- Redis

## 基于 Redis 实现分布式锁

### [#](https://javaguide.cn/distributed-system/distributed-lock-implementations.html#如何基于-redis-实现一个最简易的分布式锁)如何基于 Redis 实现一个最简易的分布式锁？

- 关键在于 互斥

```shell
127.0.0.1:6379> SETNX lockKey uniqueValue
(integer) 1
127.0.0.1:6379> SETNX lockKey uniqueValue
(integer) 0
```

```shell
127.0.0.1:6379> del lockKey  # 删除键
(integer) 1
127.0.0.1:6379> SETNX lockKey uniqueValue
(integer) 1
```

- 释放锁的原子性

```lua
// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

###  为什么要给锁设置一个过期时间？

- 避免锁无法被释放。

```shell
# SET lockKey uniqueValue ex 3 seconds [NX|XX] [GET]
127.0.0.1:6379> SET lockKey uniqueValue ex 3
OK
127.0.0.1:6379> get lockKey
"uniqueValue"
127.0.0.1:6379> get lockKey
"uniqueValue"
127.0.0.1:6379> get lockKey
(nil)
```

### 如何实现锁的优雅续期？

- **[Redisson](https://github.com/redisson/redisson)**

Redisson 中的分布式锁自带自动续期机制

- 续期的时候**判断是否是持锁线程**

![Redisson 看门狗自动续期](http://42.192.130.83:9000/picgo/imgs/distributed-lock-redisson-renew-expiration.png)

- Watch Dog 通过调用 `renewExpirationAsync()` 方法实现锁的异步续期：

```java
protected CompletionStage<Boolean> renewExpirationAsync(long threadId) {
    return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            // 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）
            "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                    "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                    "return 1; " +
                    "end; " +
                    "return 0;",
            Collections.singletonList(getRawName()),
            internalLockLeaseTime, getLockName(threadId));
}

```

```java
// 1.获取指定的分布式锁对象
RLock lock = redisson.getLock("lock");
// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制
lock.lock();
// 3.执行业务

// 4.释放锁
lock.unlock();
System.out.println(lock.isLocked());
```

### 如何实现可重入锁？

一个线程中可以多次获取同一把锁，已经有锁的线程还能获取这个锁。

- 在获取锁的时候判断是否属于当前线程。

**Redisson**实现了

1. 可重入锁（Reentrant Lock）**递归锁**
2. 自旋锁（Spin Lock）持续检查
3. 公平锁（Fair Lock）先进先出
4. 多重锁（MultiLock）获取多个锁，一次释放
5.  红锁（RedLock）“红锁算法”，允许多个节点协同工作，同时防止数据不一致。
6. 读写锁（ReadWriteLock）允许多线程读资源，写独占

### Redis 如何解决集群情况下分布式锁的可靠性？

![img](http://42.192.130.83:9000/picgo/imgs/redis-master-slave-distributed-lock.png)

- Master宕机，如何让进程获取到新Master的锁

Redlock 算法的思想是让**线程向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁**，如果客户端能够**和==半数==以上的实例成功地完成加锁操作**，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。

- > Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（[How to do distributed locking - Martin Kleppmann - 2016open in new window](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看[Redis 锁从面试连环炮聊到神仙打架open in new window](https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505097&idx=1&sn=5c03cb769c4458350f4d4a321ad51f5a&source=41#wechat_redirect)这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。

## 基于 ZooKeeper 实现分布式锁

- 比Redis更可靠
- 