### ConcurrentHashMap需要hash多少次

在 `ConcurrentHashMap` 中执行 `put` 操作时，通常需要进行两次哈希计算。

1. **第一次哈希计算**：首先，`ConcurrentHashMap` 使用键对象的 `hashCode()` 方法执行第一次哈希计算，以确定键在哈**希表中的槽位（bucket）位置**。这个槽位是一个数组索引，用于存储键值对。
2. **第二次哈希计算**：如果多个键具有相同的哈希码（即**哈希冲突**），`ConcurrentHashMap` 使用键对象的 `hashCode()` 方法的结果再次进行哈希计算，以确定最终的存储位置。

第二次哈希计算是为了解决哈希冲突。它使用了哈希算法的不同步骤，比如取模运算或位运算，以便将键值对正确地放置在哈希表中，以确保高效的查找和插入操作。

### modCount

MVCC如何实现的

### 指令重排序

1. 分配空间
2. 初始化
3. 引用

---

1. 分配空间
2. 引用
3. 初始化

**T1线程执行分配空间、引用，T2线程判断o不空，就会获取到一个==未初始化的对象==**

```
if(!=null)
	syn(){
		if(o!=null){
			o = new Object();
		}
	}
```

### 二叉平衡树和红黑树的优缺点？//TODO

红黑树作为一种自平衡二叉搜索树，具有较好的平衡性能，保证了在最坏情况下的查找、插入和删除操作的时间复杂度为 O(log N)。相比之下，**平衡树（如 AVL 树）虽然也具有良好的平衡性能，但在插入和删除操作时可能需要更多的旋转操作，导致性能的略微下降**。
