## MySQL有哪些锁？锁算法？

- 表级锁：开销小，加锁快；**不会出现死锁**；锁定粒度大，发生锁冲突的概率最高,并发度最低。MyISAM
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。BerkeleyDB

**锁算法：**

InnoDB ： 共享锁、排它锁（各种修改操作）

- 记录锁（行锁）
- 间隙锁 **RR(可重复读)** ，解决幻读，不允许插入；**间隙锁是innodb中行锁的一种**。
- 临键锁（Next-Key Locks）记录锁+间隙锁

## InnoDB 存储引擎中的锁都有哪些类型？
- 行锁（Row Locks）
  - 记录锁 Record Locks：在索引记录上加锁，只锁定单个记录。
  - 间隙锁 Gap Locks：锁定记录之间的间隙，防止其他事务插入新的记录到这个间隙中。
  - 记录+间隙 Next-Key Locks：这是 Record Lock 和 Gap Lock 的组合，它既锁定记录本身，也锁定记录前面的所有间隙。这样可以避免幻读现象的发生。
- 共享锁
  - 允许多个事务读同一行数据，但不允许写。
- 排他锁
  - 获取锁，排他写入。
- 意向锁
  - 意向共享锁（IS）：事务准备给数据行加共享锁。
  - 意向排他锁（IX）：事务准备给数据行加排他锁。
- 自旋锁
  - 操作系统
- 表锁
  - 表锁：锁定整张表，不允许其他事务访问。

## MySQL死锁如何解决？

表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。

- 设置锁超时时间

- **调整隔离级别**

  根据实际需求选择合适的隔离级别。例如，在可以接受幻读的情况下，使用**读已提交（READ COMMITTED）**隔离级别可以降低死锁的风险。但需要注意的是，降低隔离级别可能会引入其他并发问题。
   - 读未提交：
   - 读已经提交：锁定已提交的一行，允许其他事务读取已提交的行。
   - 可重复读：锁定所有行，阻止其他事务修改已锁定行的数据。
   - 可串行化：锁定所有行，阻止其他事务插入新行，阻止其他事务修改已锁定行的数据。

- 重试失败的事务

- **监控和分析死锁**：MySQL提供了一些工具和命令（如`SHOW ENGINE INNODB STATUS`）来监控和分析死锁情况

处理死锁
- 死锁检测:
MySQL数据库自动检测死锁，并且当检测到死锁时，会选择一个受害者事务进行回滚。
通过查看INFORMATION_SCHEMA.INNODB_TRX表可以获取当前活跃事务的信息，帮助诊断死锁。
- 配置参数调整:
调整innodb_lock_wait_timeout参数来设置事务等待锁超时的时间。
增加innodb_deadlock_detect参数的值为ON，开启死锁检测。
- 手动干预:
如果自动处理不满足需求，可以手动干预，比如回滚或终止某些事务。
使用KILL命令终止某个事务。
- 日志分析:
分析MySQL的错误日志文件，查找死锁发生的具体原因。
查看INFORMATION_SCHEMA.INNODB_DEADLOCK表来获取死锁信息。
  - 查看MySQL的错误日志文件，通常位于/var/log/mysql/error.log或类似的位置。
  - MySQL也会将死锁信息记录在INFORMATION_SCHEMA.INNODB_DEADLOCK表中。

- 优化SQL查询:
优化慢查询，减少锁定时间。
使用索引来加速查询，减少锁定的范围。
示例
假设我们有两个事务A和B，事务A先获取了资源X的锁
