# 数据库基础知识总结

## 数据库范式了解吗?

> 1. 1nf不可再分
> 2. 2nf非主属性完全依赖于候选键：学号，姓名，年龄，课程名称，成绩；没有分开学生和课程信息
> 3. 3nf 非主属性没有传递依赖：学号*-->系名称--->系主任
> 4. bcnf 主属性没有传递依赖：学号*--->系id\*-->系主任

![image-20220227210545915](http://42.192.130.83:9000/picgo/imgs/image-20220227210545915.png)

![image-20220227210608137](http://42.192.130.83:9000/picgo/imgs/image-20220227210608137.png)

### **1NF**（不可再分）

每个关系r的属性值都是不可分的原子值

数据库表的每一列都是**不可分割的原子数据项**，而***\*不能是集合，数组，记录等非原子数据项\****

> - `高三年1班` 应改为2个字段，一个年级、一个班级，才满足第一范式
>
> - 一个属性包含了多个电话号码的列表（"123-456-7890, 987-654-3210"）
>
>   ```java
>   | Student_ID | Student_Name | Courses                        |
>   |------------|--------------|--------------------------------|
>   | 1          | Alice        | Math, Physics                  |
>   ```

### **2NF**（非主属性完全依赖于候选键）

关系模式R是1NF，且==每个非主属性**完全函数依赖**于**候选键**(没有冗余属性)==

> ```
> | *订单id  | *产品id     | 产品名称       | *顾客id      |  顾客名称       |
> |----------|------------|--------------|-------------|---------------|
> | 1        | 101        | Laptop       | 1001        | Alice         |
> | 2        | 102        | Smartphone   | 1002        | Bob           |
> | 3        | 101        | Laptop       | 1003        | Charlie       |
> ```
>
> ```
> | *产品id     | 产品名称      |
> |------------|--------------|
> | 101        | Laptop       |
> | 102        | Smartphone   |
> 
> | *顾客id     | 顾客名称        |
> |-------------|---------------|
> | 1001        | Alice         |
> | 1002        | Bob           |
> | 1003        | Charlie       |
> 
> | *订单id   | 产品id     | 顾客id       | 订单数量        |
> |----------|------------|-------------|----------------|
> | 1        | 101        | 1001        | 2              |
> | 2        | 102        | 1002        | 1              |
> | 3        | 101        | 1003        | 3              |
> ```
>
> Name与id挂钩，在订单表里不需要有，**不要冗余属性**

### **3NF**（非主属性没有传递依赖）

> - **3nf 学号* → 系名，系名 → 系主任**
> - **bcnf 学号* → 系id*，系名id\*→ 系主任**

表中的非主键只依赖于主键，而不依赖于其他非主键

 如果关系模式R是1NF，且==每个非主属性都不传递依赖于R的候选键==，那么称R是第三范式（3NF）的模式。

- **R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖**

> ```
> | *课程id    | 课程名称     | *教师id       | 教师名称         | 部门             |
> |-----------|-------------|--------------|-----------------|------------------|
> | 101       | Math        | 501          | Dr. Smith       | Mathematics      |
> | 102       | Physics     | 502          | Dr. Johnson     | Physics          |
> | 103       | Chemistry   | 503          | Dr. Davis       | Chemistry        |
> ```
>
> - 教师名称-->教师id--->课程id
>
> ```
> | *教师id      | 教师名称          | 部门              |
> |--------------|-----------------|------------------|
> | 501          | Dr. Smith       | Mathematics      |
> | 502          | Dr. Johnson     | Physics          |
> | 503          | Dr. Davis       | Chemistry        |
> 
> | *课程id    | 课程名称     | 教师id        |
> |-----------|-------------|--------------|
> | 101       | Math        | 501          |
> | 102       | Physics     | 502          |
> | 103       | Chemistry   | 503          |
> ```

### **BC范式**（主属性没有传递依赖）

每个属性都不传递依赖于R的候选键，那么称R是BCNF的模式

- 彻底消除了插入、删除异常。

> ```
> | *员工id      | 员工名称       | *部门       | 部门位置             |
> |-------------|---------------|------------|---------------------|
> | 1001        | Alice         | HR         | New York            |
> | 1002        | Bob           | IT         | San Francisco       |
> | 1003        | Charlie       | HR         | New York            |
> ```
>
> ```
> | *部门       |  部门位置            |
> |------------|---------------------|
> | HR         | New York            |
> | IT         | San Francisco       |
> 
> | *员工id     | 员工名称        | 部门        |
> |-------------|---------------|------------|
> | 1001        | Alice         | HR         |
> | 1002        | Bob           | IT         |
> | 1003        | Charlie       | HR         |
> ```



## 什么是级联更新？为什么不推荐使用外键与级联？

- 同时触发成绩表中的 外键student_id 更新，即为级联更新。

外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

**为什么不使用？**

1. 复杂性，每次update、delete都需要考虑外键
2. 额外工作，
3. 对分库分表不友好，分库外键不生效

##  drop、delete 与 truncate 区别？

1. 用法

   > `drop`(丢弃数据): `drop table 表名` 删除表
   >
   > `truncate` (清空数据) : `truncate table 表名` ，只删除数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
   >
   > `delete`（删除数据） : `delete from 表名 where 列名=值`，删除某一行的数据，如果不加 `where` 子句和`truncate table 表名`作用类似

2. DML DDL

   - DML Database Manipulation Language CRUD
   - DDL Database Definition Language Create....

3. 一般速度delete会慢

## 数据库设计通常分为哪几步?

1. **需求分析** : 分析用户的需求，包括数据、功能和性能需求。
2. **概念结构设计** : 主要采用 E-R 模型进行设计，包括画 E-R 图。
3. **逻辑结构设计** : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
4. **物理结构设计** : 主要是为所设计的数据库选择合适的存储结构和存取路径。
5. **数据库实施** : 包括编程、测试和试运行
6. **数据库的运行和维护** : 系统的运行与数据库的日常维护。





##  CHAR 和 VARCHAR 的区别是什么？

- **CHAR 是定长字符串，VARCHAR 是变长字符串。**
- CHAR会填充空格，VARCHAR会存储使用 1 或 2 个额外字节记录字符串的长度

## DECIMAL 和 FLOAT/DOUBLE 的区别是什么？

- **DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。**

- **DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。**

  MySQL 的 DECIMAL 类型对应的是 Java 类 `java.math.BigDecimal`

## 为什么不推荐使用 TEXT 和 BLOB？

- TEXT类似CHAR、VARCHAR，但更长
- BLOB主要存二进制

> 1. 无默认值
> 2. 无法使用内存临时表
> 3. 检索效率低
> 4. 不能创建索引

## DATETIME 和 TIMESTAMP 的区别是什么？

- **TIMESTAMP 增加了时区**，会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。

- TIMESTAMP  4 个字节， DATETIME   8 个字节

  > DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
  >
  > Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59

##  NULL 和 '' 的区别是什么？

- **不确定** `NULL` 代表一个不确定的值,就算是两个 `NULL`,它俩也不一定相等。
- **空间** `''`的长度是 0，是不占用空间的，而`NULL` 是需要占用空间的。
- **聚合函数统计** `SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值，而`count(*)`会包括`NULL`
- **比较运算符** 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULLl` 来判断，`''`是可以使用这些比较运算符的

## Boolean 类型如何表示？

- 用 TINYINT(1) 类型来表示布尔值

## SQL语句在MySQL中的执行过程

[select语句执行流程.md](learning-notes\开发\数据库\Mysql\select语句执行流程.md)

> 1. 连接器
>
> 2. 缓存
>
> 3. 分析器（分析SQL）
>
>    ![img](http://42.192.130.83:9000/picgo/imgs/db-mysql-sql-parser-2.png)
>
> 4. 优化器
>
> 5. 执行器

![img](http://42.192.130.83:9000/picgo/imgs/13526879-3037b144ed09eb88.png)

### 查询语句执行过程

> 1. ```sql
>    select * from tb_student  A where A.age='18' and A.name=' 张三 ';
>    ```
>
> 2. 查询权限
>
> 3. 8.0之前会查询缓存（查询缓存只适用于Update少的场景）
>
> 4. 分析器，词法分析，错误分析
>
> 5. 优化器，先判断age还是先判断name
>
> 6. 返回执行结果

### 更新语句

> 1. ```sql
>    update tb_student A set A.age='19' where A.name=' 张三 ';
>    ```
>
> 2. 查表 
>
> 3. 修改set
>
>    - InnoDB保存到内存，记录redo log（属于InnoDB的log）
>    - 执行器记录binlog（属于所有执行引擎的log）

## ==索引==

//TODO

### 索引类型？

- **主键索引**：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。

- 二级索引：通过二级索引快速查找到主键索引

  - **普通索引**：仅加速查询。
  - **唯一索引**：加速查询 + 列值唯一（可以有 NULL）。
  - **全文索引**：对文本的内容进行分词，**进行搜索**。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建**全文索引**。一般不会使用，**效率较低**，通常使用搜索引擎如 ElasticSearch 代替。
  - 前缀索引

- **覆盖索引**：一个索引包含（或者说覆盖）所有**需要查询的字段**的值。

  - **非主键索引**中就能查到的记录，不用根据这个**查主键再查表**

    比如要查name，我直接就能查到；而不用查到id再用id回表

    ![img](http://42.192.130.83:9000/picgo/imgs/16dd033b2a2c7c24~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

- **联合索引**：**多列值**组成一个索引，专门用于**组合搜索**，其效率大于索引合并。

  - `ALTER TABLE cus_order ADD INDEX id_score_name(score, name);`

### 如何确定使用的索引类型？

- `SHOW INDEXES FROM blog_main;`

```sql
CREATE INDEX index_blog_like ON blog_main(blog_id,blog_like);
SHOW INDEXES FROM blog_main;
```

- **EXPLAIN** `EXPLAIN select blog_id,blog_like FROM blog_main`

  ![navicat_nBFrYnDhps](http://42.192.130.83:9000/picgo/imgs/navicat_nBFrYnDhps.png)

  - Extra列：该列会显示一些额外的信息，例如Using index表示查询使用了覆盖索引，Using where表示查询使用了索引，但是还需要进一步的条件过滤。
  - Key列：该列会显示使用的索引名称。如果显示为NULL，则表示没有使用索引。

### 如何创建一个索引？

- **CREATE** `CREATE INDEX index_name ON table_name (column1_name, column2_name);`

- ```sql
  CREATE TABLE table_name (
      column1_name INT,
      column2_name VARCHAR(255),
      INDEX index_name (column1_name)
  );
  ```

- **ALTER ADD**`ALTER TABLE table_name ADD INDEX index_name (column_name);`

### 二级索引是什么？有哪些？

- 通过**二级索引**，可以**定位主键的位置**

  - 唯一索引
  - 普通索引
  - 前缀索引
  - 全文索引

  ![二级索引](http://42.192.130.83:9000/picgo/imgs/no-cluster-index.png)



### 什么是索引

> 索引可以大大提高MySQL的检索速度
>
> **索引也是一张表，该表保存了==主键与索引字段，并指向实体表的记录==**
>
> 优点：提高查询速度
> 缺点：降低更新速度，更新时还要进一步保存索引文件
>
> ```sql
> CREATE INDEX index_name
> ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
> ```

- 用于**快速查询和检索数据的数据结构**，其本质可以看成是一种**排序好的数据结构**。
- 常见的索引结构有: B 树， B+树 和 Hash、红黑树。**Innodb 还是 MyIsam，都使用了 B+树作为索引结构。**

###  索引的优缺点

优点：

1. 数据的检索速度
2. 保证数据库表中每一行数据的唯一性

缺点：

1. 耗时
2. 耗空间

### hash索引相比树索引的不足

- Hash 索引不支持顺序和范围查询

> ```sql
> SELECT * FROM tb1 WHERE id < 500;
> ```
>
> - 用树只需要找到500就好
> - 用hash需要搜索<500的全部，效率低

### 还有哪些索引结构

1. AVL 平衡二叉树
2. 红黑树（限制条件避免成为链表）
3.  B 树& B+树



###  B 树& B+树的区别

> - B
>
> ![msedge_ryMzi80Nl4](http://42.192.130.83:9000/picgo/imgs/msedge_ryMzi80Nl4.png)
>
> - B+
>
> ![主键索引](http://42.192.130.83:9000/picgo/imgs/cluster-index.png)
>
> 1. B+只在叶子节点存放data
> 2. B+叶子双向链表
> 3. 查找过程：B+都是从根到底
> 4. 范围查找：B+只要在**双向链表**中查询；B需要找到下限、上限

### 非聚集索引的缺点

- 和聚集一样都需要依赖有序的数据

非聚集索引缺点：

- 需要在根据指针到对应的表再查询

![MySQL 表的文件](http://42.192.130.83:9000/picgo/imgs/mysql20210420165311654.png)



## InnoDB

### MySQL存储引擎InnoDB与Myisam的六大区别

MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。

1. InnoDB**行级锁**，更高并发

2. InnoDB支持**事务**

3. InnoDB支持**外键**

4. InnoDB基于`redo log`**异常崩溃恢复**

5. InnoDB**支持 MVCC**

6. 索引的实现

   > MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）
   >
   > - MyISAM 数据索引**分开存储**，存地址 **非聚集索引**
   > - InnoDB存的是数据。**聚集索引**

   

### MyISAM 和 InnoDB 如何选择？

- 你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）

《MySQL 高性能》上面有一句话这样写到:

> 不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。



# 进阶

### 分库分表

//TODO



## [多版本并发控制 (Multi-Version Concurrency Control)](https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#多版本并发控制-multi-version-concurrency-control)



## MySQL三大日志(binlog、redo log和undo log)详解

