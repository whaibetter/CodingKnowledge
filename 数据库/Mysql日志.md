## Mysql日志

- 二进制日志 `binlog`（归档日志）
- 事务日志 `redo log`（重做日志）
- `undo log`（回滚日志）

### Mysql有哪些日志？分别有什么特点？聊聊binlog/redolog/undolog的区别？

- 二进制日志 `binlog`（归档日志）

  1. 处于**Mysql Server层**，用于记录所有对数据库的变更
  2. **逻辑日志**，记录SQL的逻辑操作DDL（Definition），CURD
  3. 用于保证**原子性**

  - 主从复制的时候会使用

- 事务日志 `redo log`（重做日志）

  1. 属于**InnoDB**
  2. **物理日志**，记录修改的物理操作。**对应持久性**
  3. 记录了对数据库的修改操作，为了实现**持久性**

- `undo log`（回滚日志）

  1. 用于事务回滚、恢复
  2. **用于MVCC**，读取事务开始时的版本
  3. 逻辑日志

同：都在修改时记录；



### redo log的流程？

1. 查询数据，**从Buffer Pool缓存中取**（类似Redis缓存），没有再去磁盘
2. 更新数据，**直接对缓存更新**
3. **更新数据时**，把对数据页的修改记录到重做日志缓存`redo log buffer`中，再**刷盘**到`redo log file`（中间还有一个**文件系统缓存**）

![img](http://42.192.130.83:9000/picgo/imgs/03.png)

![img](http://42.192.130.83:9000/picgo/imgs/04.png)

### redo log的刷盘时间？

1. 事务提交
2. 缓存不足
3. 检查点
4. 后台刷新线程、每秒1次默认
5. 关闭服务器

`innodb_flush_log_at_trx_commit` 的值有 3 种，也就是共有 3 种刷盘策略：

- **0**：设置为 0 的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。**只会每1秒后台刷新一次**
- **1**：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。**事物提交就刷盘**
- **2**：设置为 2 的时候，表示每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。

![](http://42.192.130.83:9000/picgo/imgs/04.png)

### 一个没有提交事务的 `redo log` 记录，也可能会刷盘？

- 进入redo log  buffer的事务，后台线程1s被刷入

 ![img](http://42.192.130.83:9000/picgo/imgs/05.png)

![](http://42.192.130.83:9000/picgo/imgs/04.png)

### 为什么要redo log？每次写数据就刷盘不就好了？

- **刷盘很耗时**。如每次写几个byte也要刷盘，效率就太低了
- 数据页时随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。

### binlog是什么？有什么应用？

- **bin log 属于Mysql Server层**。是逻辑日志，记录内容是语句的原始逻辑

- 不管用什么存储引擎，只要发生了表**数据更新**，都会产生 `binlog` 日志。

  可以说`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据一致性。

### binlog写入机制？

1. 事务执行过程中，先把日志写到`binlog cache`
2. **事务提交的时候，再把`binlog cache`write到`binlog`文件中。**

因为一个事务的`binlog`不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给**每个线程分配一个块内存作为`binlog cache`。**

- **write 写入文件系统缓存（不是binlog cache）**
- **fsync 持久化到磁盘**

![img](http://42.192.130.83:9000/picgo/imgs/04-20220305234747840.png)

`write`和`fsync`的时机，可以由参数`sync_binlog`控制，默认是`1`。

0. 每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。
1. 每次提交事务都会执行`fsync`，就如同 **redo log 日志刷盘流程** 一样。
2. `N(N>1)`，表示每次提交事务都`write`，但累积`N`个事务后才`fsync`。**适合IO瓶颈场景，多个再提交**

### bin log 和 redo log 的主要作用区别？

- redo log 是InnoDB 支持**崩溃恢复**，redo log 可以**不断写入**
- bin log 保证**Mysql集群**的一致性，bin log 只有**提交事务**才写入

### 两阶段提交是什么？解决了什么问题？

- 防止redo log和bin log不一致，如redo log 出现错误。
- 将`redo log`的写入拆成了两个步骤`prepare`和`commit`

> - 如果binlog异常，还没commit redo log 会回滚
>
> ![img](http://42.192.130.83:9000/picgo/imgs/06-20220305234907651.png)
>
> - 如果redo log commit异常，还在prepare阶段，但有binlog存在，所以不会回滚
>
> ![img](http://42.192.130.83:9000/picgo/imgs/04-20220305234956774.png)

### undo log是什么？有什么应用？

- 用于进行事务回滚操作。
- MVCC事务，读取之前版本的数据。**非锁定读**