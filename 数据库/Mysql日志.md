## Mysql日志

- 二进制日志 `binlog`（归档日志）
- 事务日志 `redo log`（重做日志）
- `undo log`（回滚日志）

### 怎么查看这些log？

**Binlog（二进制日志）**：SHOW BINARY LOGS;

1. 查看Binlog文件：可以使用MySQL的命令行工具或者图形化工具来查看Binlog文件。在命令行中，可以执行`SHOW BINARY LOGS;`命令来列出所有的Binlog文件，然后使用`SHOW BINLOG EVENTS IN 'log_file_name';`命令来查看具体的Binlog事件。

**Redo Log（重做日志）**：无法直接查看

1. 查看Redo Log文件：Redo Log是MySQL的内部日志，通常无法直接查看。但是可以通过配置参数来查看Redo Log的相关信息。例如，通过设置`innodb_log_file_size`参数的值可以控制Redo Log文件的大小。

**Undo Log（撤销日志）**：无法直接查看其内

1. 无法直接查看Undo Log：Undo Log是MySQL内部使用的日志，无法直接查看其内容。它主要用于事务回滚和并发控制，对于普通用户来说，一般不需要直接查看Undo Log。

需要注意的是，对于Redo Log和Undo Log，这些日志文件通常是MySQL的内部文件，普通用户无法直接查看其内容。它们的管理和维护由MySQL数据库引擎自动处理。对于Binlog，可以使用相关的命令或者工具来查看和管理。另外，还可以使用第三方的日志分析工具来解析和分析这些日志文件的内容。



### Mysql有哪些日志？分别有什么特点？聊聊binlog/redolog/undolog的区别？

不同的粒度

- 二进制日志 `binlog`（归档日志）**逻辑日志**

  记录数据库表结构和表表数据的变更

  - 处于**Mysql Server层**，用于记录所有对数据库的变更
  - **逻辑日志**，记录SQL的逻辑操作DDL（Definition），CURD
  - 用于保证**原子性**
  - Binlog 的记录是在**事务提交**时生成的

  - 主从复制的时候会使用，一种记录数据库修改操作的日志，用于实现**数据库的备份、恢复和复制**等功能

- 事务日志 `redo log`（重做日志，**“事务”**）**物理日志**

  1. 属于**InnoDB**
  2. **物理日志**，记录修改的物理操作。**对应持久性和数据一致性**
  3. 记录了对数据库的修改操作，为了实现**持久性**

  - 使用后台进程将Redo Log buffer写入Redo log file

- `undo log`（回滚日志）

  1. 用于事务回滚、恢复；**在事务执行过程中生成**
  2. **用于MVCC**，读取事务开始时的版本
  3. 逻辑日志

同：都在修改时记录；

### InnoDB更新数据的过程？

InnoDB是MySQL数据库中的一种存储引擎，负责管理数据的存储和检索。下面是InnoDB更新数据的一般过程：

1. **查询数据行**：首先，根据指定的条件执行一条更新语句（例如UPDATE语句），InnoDB会根据条件查询匹配的数据行。
2. **行锁定**：在执行更新之前，InnoDB会对查询到的数据行进行行级别的锁定，以确保在更新过程中其他事务不能修改或读取这些数据行。
3. **生成回滚日志**：在更新数据之前，InnoDB会生成事务的==**回滚日志（undo log）**==。回滚日志用于在事务回滚或崩溃恢复时撤销对数据的更改。
4. **修改数据**：InnoDB更新数据行的方式是先在内存中修改数据，然后再将修改写入磁盘。具体步骤如下：
   - 将要修改的数据行**从磁盘读入内存的缓冲池（buffer pool）中**。
   - **在缓冲池中对数据行进行修改**。这里包括对数据的插入、删除、更新等操作。
   - 在缓冲池中**生成事务的==重做日志（redo log）==**，用于在事务提交后将修改操作持久化到磁盘。
   - 更新完成后，InnoDB将修改后的数据**写入磁盘中对应的数据文件**。
5. **事务提交**：如果更新操作是在一个事务中进行的，当**事务提交时（1s也会触发....缓存不足也会触发），InnoDB会将事务的==重做日志redo log持久化到磁盘==，确保数据的持久性**。同时，InnoDB会释放行级别的锁定，允许其他事务访问更新后的数据。

需要注意的是，InnoDB的更新过程可能涉及到其他操作，如索引的更新和维护。此外，InnoDB还使用了**多版本并发控制（MVCC）机制来支持并发事务**，保证了数据的**一致性和隔离性**。

总结来说，InnoDB更新数据的过程包括**查询数据行、行锁定、生成回滚日志、修改数据和事务提交**。这些步骤确保了数据的一致性、持久性和并发控制。

![img](http://42.192.130.83:9000/picgo/imgs/03.png)


InnoDB 存储引擎在 MySQL 中负责事务处理和行级锁定，它在更新数据时遵循一系列严格的过程，以确保数据的一致性和事务的ACID（原子性、一致性、隔离性、持久性）特性。以下是 InnoDB 更新数据的大致过程：
1. 加载数据到缓存中：

InnoDB 首先在缓冲池（Buffer Pool）中查找要更新的记录是否已经在内存中。如果记录不在内存中，InnoDB 会从磁盘加载相应的数据页到缓冲池。
2. 加锁：

InnoDB 使用行级锁定机制，因此在更新数据之前，它会对要更新的行加锁，以防止其他事务同时修改同一行数据。 
3. 写入 UNDO 日志：

在更新数据前，InnoDB 会将旧值写入 UNDO 日志中。UNDO 日志用于事务回滚，如果事务需要回滚，InnoDB 可以使用 UNDO 日志恢复数据到更新前的状态。

4. 更新内存数据：

更新缓冲池中的数据页数据信息，即实际修改数据。

5. 写入 REDO 日志：

InnoDB 会将更新操作写入 REDO 日志中，REDO 日志用于崩溃恢复，确保在系统崩溃后数据可以恢复到更新后的状态。

6. 提交事务：

当事务提交时，InnoDB 会在 REDO 日志中记录一个 COMMIT 标记，表示事务完成。此时，虽然数据在内存中已经更新，但尚未同步到磁盘。

7. 异步刷新 REDO 日志和数据页：

InnoDB 会定期或在满足一定条件时，异步地将 REDO 日志和修改过的数据页刷新到磁盘上。默认情况下，InnoDB 每秒至少刷新一次 REDO 日志。

8. 更新索引：

如果更新操作影响到索引，InnoDB 也会相应地更新索引信息，包括主键索引和其他辅助索引。
整个更新过程确保了事务的隔离性和持久性，即使在系统崩溃的情况下，InnoDB 也能通过 REDO 日志和 UNDO 日志恢复数据，保持数据的一致性。此外，InnoDB 的更新操作是原子的，要么全部完成，要么完全不执行，这保证了事务的原子性。

### redo log的流程？

1. 查询数据，**从Buffer Pool缓存中取**（类似Redis缓存），没有再去磁盘
2. 更新数据，**直接对缓存更新**
3. **更新数据时**，把对数据页的修改记录到重做日志缓存`redo log buffer`中，再**刷盘**到`redo log file`（中间还有一个**文件系统缓存**）

![img](http://42.192.130.83:9000/picgo/imgs/03.png)

![img](http://42.192.130.83:9000/picgo/imgs/04.png)

### redo log的刷盘时间？

1. 事务提交
2. 缓存不足
3. 检查点
4. 后台刷新线程、每秒1次默认
5. 关闭服务器

`innodb_flush_log_at_trx_commit` 的值有 3 种，也就是共有 3 种刷盘策略：

- **0**：设置为 0 的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。**只会每1秒后台刷新一次**
- **1**：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。**事物提交就刷盘**
- **2**：设置为 2 的时候，表示每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。

![](http://42.192.130.83:9000/picgo/imgs/04.png)

### 一个没有提交事务的 `redo log` 记录，也可能会刷盘？

- 进入redo log  buffer的事务，后台线程1s被刷入

 ![img](http://42.192.130.83:9000/picgo/imgs/05.png)

![](http://42.192.130.83:9000/picgo/imgs/04.png)

### 为什么要redo log？每次写数据就刷盘不就好了？

- **刷盘很耗时**。如每次写几个byte也要刷盘，效率就太低了
- 数据页时随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。

### binlog是什么？有什么应用？

- **bin log 属于Mysql Server层**。是逻辑日志，记录内容是语句的原始逻辑

- 不管用什么存储引擎，只要发生了表**数据更新**，都会产生 `binlog` 日志。

  可以说`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据一致性。

### binlog写入机制？

1. 事务执行过程中，先把日志写到`binlog cache`
2. **事务提交的时候，再把`binlog cache`write到`binlog`文件中。**

因为一个事务的`binlog`不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给**每个线程分配一个块内存作为`binlog cache`。**

- **write 写入文件系统缓存（不是binlog cache）**
- **fsync 持久化到磁盘**

![img](http://42.192.130.83:9000/picgo/imgs/04-20220305234747840.png)

`write`和`fsync`的时机，可以由参数`sync_binlog`控制，默认是`1`。

0. 每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。
1. 每次提交事务都会执行`fsync`，就如同 **redo log 日志刷盘流程** 一样。
2. `N(N>1)`，表示每次提交事务都`write`，但累积`N`个事务后才`fsync`。**适合IO瓶颈场景，多个再提交**

### bin log 和 redo log 的主要作用区别？

- redo log 是InnoDB 支持**崩溃恢复**，redo log 可以**不断写入**
- bin log 保证**Mysql集群**的一致性，bin log 只有**提交事务**才写入

### 两阶段提交是什么？解决了什么问题？

- 防止redo log和bin log不一致，如redo log 出现错误。
- 将`redo log`的写入拆成了两个步骤`prepare`和`commit`

> - 如果binlog异常，还没commit redo log 会回滚
>
> ![img](http://42.192.130.83:9000/picgo/imgs/06-20220305234907651.png)
>
> - 如果redo log commit异常，还在prepare阶段，但有binlog存在，所以不会回滚
>
> ![img](http://42.192.130.83:9000/picgo/imgs/04-20220305234956774.png)

### undo log是什么？有什么应用？

- 用于进行事务回滚操作。
- MVCC事务，读取之前版本的数据。**非锁定读**